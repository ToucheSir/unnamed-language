grammar UnnamedLanguage;

tokens {
	KW_TRUE      = 'true';
	KW_FALSE     = 'false';
	KW_IF        = 'if';
	KW_ELSE      = 'else';
	KW_WHILE     = 'while';
	KW_PRINT     = 'print';
	KW_PRINTLN   = 'println';
	KW_RETURN    = 'return';
	KW_INT 		   = 'int';
	KW_FLOAT	   = 'float';
	KW_CHAR		   = 'char';
	KW_STRING	   = 'string';
	KW_BOOLEAN   = 'boolean';
	KW_VOID		   = 'void';
}
///*

@members
{
protected void mismatch (IntStream input, int ttype, BitSet follow)
        throws RecognitionException
{
        throw new MismatchedTokenException(ttype, input);
}
public void recoverFromMismatchedSet (IntStream input,
                                      RecognitionException e,
                                      BitSet follow)
        throws RecognitionException
{
        reportError(e);
        throw e;
}
}

@rulecatch {
        catch (RecognitionException ex) {
                reportError(ex);
                throw ex;
        }
}

//*/
program
	:	function+ EOF;

function
	:	functionDecl functionBody ;
	
functionDecl
	:	compoundType identifier '(' formalParameters ')' ;
	
formalParameters
	: // Empty parameter list
	|	compoundType identifier moreFormals*
	;
	
moreFormals
	:	',' compoundType identifier ;
	
functionBody
	:	'{' varDecl* statement* '}' ;

varDecl	:	compoundType identifier ';' ;

compoundType
	:	type
	|	type '[' INTEGER_CONSTANT ']'
	;
	
type
	:	KW_INT
	|	KW_FLOAT
	|	KW_CHAR
	|	KW_STRING
	|	KW_BOOLEAN
	|	KW_VOID
	;
    
statement options {backtrack=true;}
	: ';'
	| KW_IF '(' expr ')' block (KW_ELSE block)?
	|	KW_WHILE '(' expr ')' block
	|	KW_PRINT expr ';'
	|	KW_PRINTLN expr ';'
	|	KW_RETURN expr? ';'
	|	identifier '[' expr ']' '=' expr ';' 
	|	identifier '=' expr ';'
	|	expr ';'
	;

block
	:	'{' statement* '}' ;

expr
	: exprEquals ;

exprEquals
	: exprLessThan (OP_EQUALS exprLessThan)*
	;

exprLessThan
	: exprPlusMinus (OP_LESSTHAN exprPlusMinus)*
	;

exprPlusMinus
	: exprMul ((OP_PLUS|OP_MINUS) exprMul)*
	;

exprMul
	: atom (OP_MUL atom)*
	;
	
atom
	: identifier '[' expr ']'
	| identifier '(' exprList ')' 
	| identifier 
	| literal 
	| '(' expr ')'
	;

literal
	:	STRING_CONSTANT
	|	INTEGER_CONSTANT
	|	FLOAT_CONSTANT
	|	CHARACTER_CONSTANT
	|	KW_TRUE
	|	KW_FALSE
	;

exprList
	:	expr exprMore*
	|
	;

exprMore
	:	',' expr;

identifier
  : ID ;
	
// Lexer Rules
OP_EQUALS
	:	'==';
OP_PLUS
	:	'+';
OP_MINUS
	:	'-';
OP_LESSTHAN
	:	'<';
OP_MUL
	:	'*';
		
ID:	('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'0'..'9'|'_')*	;

INTEGER_CONSTANT
	:	('0' | ('1'..'9'('0'..'9')*)) ;

// All of the following lexical elements here were auto-generated by ANTLRWORKS
FLOAT_CONSTANT
	:	('0'..'9')+ '.' ('0'..'9')* EXPONENT?
	|	'.' ('0'..'9')+ EXPONENT?
	|	('0'..'9')+ EXPONENT
  ;

STRING_CONSTANT
	:  '"' ( ESC_SEQ | ~('\\'|'"') )* '"'
	;

CHARACTER_CONSTANT
	:  '\'' ( ESC_SEQ | ~('\''|'\\') ) '\'' ;

fragment
EXPONENT : ('e'|'E') ('+'|'-')? ('0'..'9')+ ;

fragment
HEX_DIGIT : ('0'..'9'|'a'..'f'|'A'..'F') ;

fragment
ESC_SEQ
	:	'\\' ('b'|'t'|'n'|'f'|'r'|'\"'|'\''|'\\')
	|	UNICODE_ESC	
	|	OCTAL_ESC
	;

fragment
OCTAL_ESC
	:	'\\' ('0'..'3') ('0'..'7') ('0'..'7')
	|	'\\' ('0'..'7') ('0'..'7')
	|	'\\' ('0'..'7')
	;
    
COMMENT
	:	'//' ~('\n'|'\r')* '\r'? '\n' {$channel=HIDDEN;} ;

WS 
: ( ' '
	| '\t'
	| '\r'
	| '\n'
) {$channel=HIDDEN;}
;

fragment
UNICODE_ESC
	:	'\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT ;
